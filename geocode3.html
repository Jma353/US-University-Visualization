<!DOCTYPE html> 
<html>
	<head>
		<style>


			/* Overall HTML */
			html {
				font-family: "Avenir Next" !important; 
			}


			/* SVG styling + drawing animation */
			svg {
				fill: #B58AA5; /* Purple fill #B58AA5 */
				stroke: #6e455f; /* black path */
			    stroke-dasharray: 2000px;
			    stroke-dashoffset: 2000px;
			    animation-name: draw;
			    animation-duration: 3s;
			    animation-fill-mode: forwards;
			    animation-iteration-count: 1;
			    animation-timing-function: linear;
				
				border:1px black; /*temporary*/
			}


			/* University circle styling */
			circle {
				stroke: white;
				stroke-width:1.4px;
			}


			/* Map circle (university mapping) styling */
			.map-circle {

			}


			/* Drawing animation on startup */
			@keyframes draw {
				to {
					stroke-dashoffset: 0;
				}
			}


			/* US Map styling */
			#mapSVG, #linRegSVG {
				margin-left: -200px;
				margin-top: -20px;
			}
			

			/* General SVG text styling */
			text, .graph-text {
				fill: #c4a1b7;
				stroke: #c4a1b7;
				font-size:70%;
			}

			
			/* University info name styling */
			#univName {
			    fill: #8d587a;
				stroke: #6e455f;
				stroke-width:0.3px;
				font-size:110%;
				text-anchor:middle;
			}


			/* University info text styling */
			#univInfo {
				stroke-width: 0.3px;
				text-anchor: middle;
				font-size: 75%;
			}


			/* Clustering styling */
			.clustering {
				border: solid black 1px; 
			}


			/* Axes styling (courtesy of https://bl.ocks.org/mbostock/3887118 example) */ 
			.axis path, 
			.axis line {
				fill: none;
				stroke: ;
				shape-rendering: crispEdges;
			}


			/* Graph text size change */
			.graph-text { 
				font-size: 45%; 
			}

			/* Button styling achieved through using this tool: http://css3buttongenerator.com/ */ 

			/* Clustering button styling */ 
			.btn {
				-webkit-border-radius: 10;
				-moz-border-radius: 10;
				border-radius: 10px;
				color: #ffffff;
				font-size: 17px;
				background: #B58AA5;
				padding: 7px 17px 7px 17px;
				text-decoration: none;
				text-align: center; 
				cursor:pointer;
			}


			/* Button hover styling */
			.btn:hover {
				background: #825A6C;
				text-decoration: none;
			}


			/* Clustering button layout */ 
			.cluster-btn {
				width: 120px; 
				margin-left: 50px; 
				margin-top: 30px; 
				float: left;
				margin-bottom: 20px;
				cursor:pointer;
			}

			.start-cluster, .reset-btn {
				-webkit-border-radius: 10;
				-moz-border-radius: 10;
				border-radius: 10px;
				border-color: #B58AA5; 
				border: 1px solid; 
				width: 120px; 
				padding: 7px 17px 7px 17px;
				margin-left: 150px; 
				margin-top: 20px; 
				float: left; 
				color: #B58AA5;
				text-align: center; 
				text-decoration: none; 
				font-size: 25px; 
				cursor:pointer;
			}

			.start-cluster:hover, .reset-btn:hover {
				color: #825A6C;
				text-decoration: none;
			}



			/* Header styling */
			.title-header {
				font-size: 150%; 
				margin-left: 50px; 
				margin-top: 10px; 
				color: #825A6C;
			}


			/* Sub-header styling */
			.title-subheader {
				font-size: 120%; 
				margin-top: 20px;
				margin-left: 50px; 
			}


		</style> 
	</head> 

	<body>
		
	    <!-- D3 --> 
		<script type="text/javascript" src="d3/d3.min.js"></script> 
		<!-- jQuery for some animations and UI stuff --> 
		<script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
		<!-- TopoJSON for the map --> 
		<script type="text/javascript" src="http://d3js.org/topojson.v0.min.js"></script>
		<!-- k-means clustering functions we wrote --> 
		<script type="text/javascript" src="js/kcluster.js?1"></script> 
		<!-- linear regression functions we wrote --> 
		<script type="text/javascript" src="js/linreg.js?2"></script> 

		<!-- Title --> 	
		<div class="title-header" style="font-size: 30px"><i>K</i>-Means Clustering and Linear Regressions of U.S. Universities and Colleges</div> 
		<!-- Subtitle --> 
		<div class="title-subheader">Select 2 parameters to cluster by</div> 


		<!-- Clustering buttons --> 
		<div class="btn cluster-btn admin" style="width: 150px;" data="admissions_info">Admissions Rate</div> 
		<div class="btn cluster-btn sat" data="score_info">SAT Score</div> 
		<div class="btn cluster-btn salary" style="width: 300px;" data="salary_info">Median Mid-Career Salary</div> 
		<div class="start-cluster">Cluster</div>
		<div class="reset-btn" style="margin-left: 20px;">Reset</div>

		<div class="title-subheader" style="clear: both;">Select states whose universities you'd like to cluster</div> 
		<!-- Where the map goes --> 
		<div class="us-map">

			<!-- This is the absolute threshold size to disallow scrolling on a regular 13-inch monitor --> 
	         <svg width="1580" height="647" id="mapSVG"> 
	         	<text x="650" y="60" id="univName">Interactive: Hover over any circle on map or graph</text>
			 	<text x="650" y="80" id="univInfo"></text>
			 </svg>

			<!-- Title --> 	
			<div class="title-header" style="font-size: 30px; margin-bottom: 30px;">Linear Regressions of Various University Parameters</div> 
			<!-- Linear regression graphs  --> 
			<svg width="1580" height="650" id="linRegSVG"></svg> 

		</div> 




		
		<!-- Start of JS --> 
		<script>

			// From http://stackoverflow.com/questions/14167863/how-can-i-bring-a-circle-to-the-front-with-d3 
			// Solves the issue of bringing an element to the front 
			d3.selection.prototype.moveToFront = function() {
				return this.each(function() {
					this.parentNode.appendChild(this); 
				}); 
			}

			// From http://stackoverflow.com/questions/14167863/how-can-i-bring-a-circle-to-the-front-with-d3  
			// Solves the issue of moving an element to the back 
			d3.selection.prototype.moveToBack = function() { 
			    return this.each(function() { 
			        var firstChild = this.parentNode.firstChild; 
			        if (firstChild) { 
			            this.parentNode.insertBefore(this, firstChild); 
			        } 
			    }); 
			};


			// Map guide used: 
			// https://bl.ocks.org/mbostock/4090848



			/* ALL THE VARIABLES WE NEED TO TRACK GLOBALLY */

			// Assign dimensions of SVG element 
			var width = 1300; 
			var height = 610; 

			// Colors 
			var DARK_PURPLE = "#825A6C"; 
			var LIGHT_PURPLE = "#B58AA5"
			var PINK = "#E39AB2"
			var CLUSTER_PINK = "#FF9AB2"

			// Global list of university JSONs 
			var uniJSONs; 

			// Selected parameters to cluster by 
			var selectedParms = [];  

			// Selected states to include universities to cluster 
			var selectedStates = []; 

			// Set the projection, based on the fact that we're using a US map 
			var projection = d3.geo.albersUsa().scale(1000).translate([width / 2, height / 2]); 

			// Set the path based on this projection 
			var path = d3.geo.path().projection(projection); 

			// SVG element 
			var svg = d3.select("#mapSVG"); 
			

			// Map radii for various situations 
			var defCircleR = 3; 
			var largeCircleR = 10; 



			// xScale + yScale 
			var xScale; 
			var yScale; 

			// Axes 
			var xAxis; 
			var yAxis; 

			// Overall data for clustering
			var overAllData = []; 

			// To refer to types of data via selected clustering categories 
			var DATA_MAPPINGS = {
									"score_info" : "mean_sat_score", 
									"admissions_info" : "acceptance_rate",
									"salary_info" : "mid_career_median_salary"
								}


			// To refer to the titles of the generated graphs 
			var TITLE_MAPPINGS 	= 	{
										"mean_sat_score" : "SAT Score",
										"acceptance_rate" : "Acceptance Rate (%)",
										"mid_career_median_salary" : "Median Mid-Career Salary ($)"
								 	}


			// The container SVG for the cluster graph
			var clusterSVG;


			// Where the SVG goes for the clustering 
			var cSVG; 


			// Dimensions of the clustering graph
			var clusterHeight = 450; 
			var clusterWidth = 450; 
			var padding = 60; 	

			// Offsets for the clustering graph 
			var xGraphOffset = 1050; 
			var yGraphOffset = 100; 



			// Cluster circles 

			var clusterCircleSize = 5; 
			var clusterCircleExpanded = 9; 

			// Data for cluster line
			var clusterLines = []; 

			// Line SVG elements 
			var thaLines; 


			/* END OF GLOBAL VARIABLE INIT */


			// Cluster dot mouseover callback function 
			function mouseOverCallback (d, selectedElmt) {

				var circ = selectedElmt; 
				circ.transition().attr("r", clusterCircleExpanded).style("fill", "white"); 
				circ.moveToFront(); 
                cSVG.selectAll(".clusterDot").moveToFront();
				// Select map elements 
				var skool = d["school"]; 
				var mapElements = d3.selectAll(".map-circle").filter(function (d) {
					return d["school"] == skool; 
				}); 

				// Reset and move to back 
				mapElements.transition().attr("r", largeCircleR); 
				mapElements.moveToFront(); 

         		// Label at the top w/info 
				d3.select("#univName").text(d["school"]);
				d3.select("#univInfo").text("SAT Score: " + d["score_info"]["mean_sat_score"] + " | Admission Rate: "+d["admissions_info"]["acceptance_rate"]+"% | Median Mid-career Salary: $"+d["salary_info"]["mid_career_median_salary"]);

			}



			// Cluster dot mouseleave callback function 
		 	function mouseLeaveCallback (d, selectedElmt) {

				var circ = selectedElmt; 
				circ.transition().attr("r", clusterCircleSize).style("fill", DARK_PURPLE); 
				circ.moveToBack(); 
				
				// Get the lines that apply to this clusterId + move them to back 
				var clusterId = selectedElmt.data()[0]["clusterId"]
				d3.selectAll(".cluster-line").filter(function (d) {
					return d["clusterId"] == clusterId; 
				}).moveToBack(); 


				// Select map elements 
				var skool = d["school"]; 
				var mapElements = d3.selectAll(".map-circle").filter(function (d) {
					return d["school"] == skool; 
				}); 

				// Reset and move to back 
				mapElements.transition().attr("r", defCircleR); 
				


				// Reset top label 
				d3.select("#univName").text("Interactive: Hover over any circle on map or graph");
				d3.select("#univInfo").text("");

		 	}



		 	// Universal cluster line adding function 
		 	function addClusterLines (newClusters, svg) {
				// Accumulate dot - cluster associations 
				clusterLines = []; 
				newClusters.each(function (d) {
					// Get all the cluster-circles w/appropriate clusterId 
					var clusterId = d["id"]; 
					var assocCircles = svg.selectAll(".cluster-circle").filter(function (f) {
						return f["clusterId"] == clusterId; 
					});

					assocCircles.each(function (n) {
						var lineJSON = { x1: n["cx"], y1: n["cy"], x2: d["cx"], y2: d["cy"], clusterId: clusterId }
						clusterLines.push(lineJSON); 
					}); 
				});
				
				// Move the lines to the back of the display
				var lineSVGs = svg.selectAll(".cluster-line")
									.data(clusterLines).enter()
								.append("line")
									.attr("x1", function (d) { return d.x1; })
									.attr("y1", function (d) { return d.y1; })
									.attr("x2", function (d) { return d.x2; })
									.attr("y2", function (d) { return d.y2; })
									.attr("class", "cluster-line")
									.style("opacity", 0)
									.style("stroke", LIGHT_PURPLE)
									.style("stroke-width", 0.5)
				lineSVGs.transition().duration(1000).style("opacity", 1.0); 
				return lineSVGs; 
		 	}


		 	// Entering the centroid 
		 	function clusterMouseOver (d) {
				//highlight circles in same cluster **AA**
				var cId = d["id"]; 
				var skools=[];
				var aCircles = svg.selectAll(".cluster-circle")
							.filter(function (f) {
								if (f["clusterId"] == cId){
									skools.push(f["school"]);
									return true;
								} else {
									return false;
								} 
							});
				aCircles.transition().attr("r", clusterCircleExpanded).style("fill", "white");
				skools.forEach(function (s) {
			   		var mElements = d3.selectAll(".map-circle").filter(function (d) { return d["school"] == s; }); 
                	// Reset and move to back 
			   		mElements.transition().attr("r", largeCircleR); 
			    	mElements.moveToFront(); 
			    });
		 	}


		 	// Leaving the centroid 
		 	function clusterMouseLeave (d) {
				//highlight circles in same cluster **AA** 
				var cId = d["id"]; 
				var skools=[];
				var aCircles = svg.selectAll(".cluster-circle").filter(function (f) {
							if (f["clusterId"] == cId) {
								skools.push(f["school"]);
								return true;
							} else {
								return false;
							} 
						});

				aCircles.transition().attr("r", clusterCircleSize).style("fill", DARK_PURPLE);
				skools.forEach(function (s) {
			    	var mElements = d3.selectAll(".map-circle").filter(function (d) { return d["school"] == s; }); 
                	// Reset and move to back 
			    	mElements.transition().attr("r", defCircleR); 
				});
		 	}



			// load the map JSON 
			d3.json("us-states.json", function(error, json) {

				if (error) throw error; 

				svg.selectAll("path")
					.data(json.features)
					.enter()
					.append("path")
					.attr("d", path)
					.attr("class", "state")
					.on("mouseover", function (d) {

						// Only reset non-selected states 
						var nonSelectedStates = d3.selectAll(".state").filter(function (d) {
							var inArray = false
							selectedStates.forEach( function (s) {
								inArray = inArray || (d["properties"]["name"] == s) 
							}); 
							return !inArray
						}).style("fill", LIGHT_PURPLE); // Set all equal to this color

						// Make the state that we're hovering over pink 
						d3.select(this).style("fill", PINK); 

						// Only move these back to original color if they're not part of the highlights / select state groupings
						var nonSelectedMapCircles = d3.selectAll(".map-circle")
														.filter(function (d) {
															var inArray = false; 
															selectedStates.forEach(function (s) {
																inArray = inArray || (s == d["location_info"]["state"]); 
															}); 
															return !inArray; 
														}).style("fill", DARK_PURPLE).style("stroke", "white"); 

					})
					.on("click", function (d) {
						// Get the selected SVG element 
						var s = d3.select(this); 

						// Get the state name 
						var state = d["properties"]["name"]

						// Check to see if this state is already in the array 
						var inArray = false; 
						selectedStates.forEach(function (e) {
							inArray = inArray || (state == e); 
						}); 

						// If this state is not in the array 
						if (!inArray) {
							// Add it to the array 
							selectedStates.push(state); 
							// Make the fill pink 
							s.style("fill", PINK); 
							// Find the circles we need to highlight 
							var relevantCircles = d3.selectAll(".map-circle")
													.filter(function (d) {
														// Find the state 
														var circleState = d["location_info"]["state"]; 
														circleState = circleState == "District of Columbia" ? "Maryland" : circleState; 
														return circleState == state; 
													}); 
							relevantCircles.style("stroke", LIGHT_PURPLE).style("fill", "white"); 
						}


					}).on("mouseleave", function (d) {
						// Get the state name 
						var state = d["properties"]["name"]

						// Check to see if this state is already in the array 
						var inArray = false; 
						selectedStates.forEach(function (e) {
							inArray = inArray || (state == e); 
						}); 

						// If not in array, make the fill light purple again (b/c mouse out)
						if (!inArray) {
							d3.select(this).style("fill", LIGHT_PURPLE); 
						}

						// Control highlighting well 
						var appropMapCircles = d3.selectAll(".map-circle").filter(function (d) {
							var inArray = false; 
							selectedStates.forEach(function (e) { 
								inArray = inArray || (d["location_info"]["state"] == e); 
							});
							return !inArray 
						});  

						appropMapCircles.style("fill", DARK_PURPLE).style("stroke", "white"); 

					}); 

			}); 
	




			// load the universities 
			d3.json('UNIVERSITIES.json', function(error, data) {
					
				// Mapping inspiration taken from 
				// http://chimera.labs.oreilly.com/books/1230000000345/ch12.html#_adding_points


				// Set the data of the universities equal to the global variable tracking it 
				uniJSONs = data; 

				// Add field `mean_sat_score` to `score_info` section 
				for (var i = 0; i < data.length; i++) {
					var meanMathSATScore = (data[i]["score_info"]["sat_math_low"] + data[i]["score_info"]["sat_math_high"]) / 2; 
					var meanReadingSATScore = (data[i]["score_info"]["sat_reading_low"] + data[i]["score_info"]["sat_reading_high"]) / 2; 
					var meanSATScore = meanMathSATScore + meanReadingSATScore; 
					data[i]["score_info"]["mean_sat_score"] = meanSATScore; 
				}

				//circles
				svg.selectAll("circle")
					.data(data)
					.enter()
					.append("circle")
					.attr("cx", function(d) {
						var lat = d["location_info"]["lat"]; 
						var lng = d["location_info"]["lng"]; 
						return projection([lng, lat])[0]; 
					})
					.attr("cy", function(d) {
						var lat = d["location_info"]["lat"]; 
						var lng = d["location_info"]["lng"]; 
						return projection([lng, lat])[1]; 
					})
					.attr("r", defCircleR)
					.attr("data", function(d) {
						return data.indexOf(d); // Return the index of the data we care about
					})
					.attr("class", "map-circle")
					.style("fill", DARK_PURPLE).style({'cursor':'pointer'})
					.on("mouseover", function(d) {

						// On hover of a circle in a particular state, highlight that state 
						var circleState = d["location_info"]["state"]
						d3.selectAll(".state").filter(function (d) {
							return d["properties"]["name"] == circleState; 
						}).style("fill", PINK); 


						// Highlight relevant circles 
						var sel = d3.select(this); 
						sel.moveToFront(); 
						sel.transition().duration(500).attr("r", largeCircleR); 
                 			

                 		// Highlight relevant cluster on the cluster graph (if it exists) + move to front 
                 		var circleSchool = d["school"]; 
                 		var corrCluster = d3.selectAll(".cluster-circle").filter(function (d) {
                 			return d["school"] == circleSchool; 
                 		}); 
                 		corrCluster.transition().duration(500).attr("r", clusterCircleExpanded).style("fill", "white"); 
                 		corrCluster.moveToFront(); 



                 		// Label at the top 
						d3.select("#univName").text(d["school"]);
						d3.select("#univInfo").text("SAT Score: " + d["score_info"]["mean_sat_score"] + " | Admissions Rate: "+d["admissions_info"]["acceptance_rate"]+"% | Median Mid-career Salary: $"+d["salary_info"]["mid_career_median_salary"]);


					})
					.on("mouseleave", function(d) {

						// Reset radius 
						d3.select(this).transition().duration(500).attr("r", defCircleR);

                 		// Reset cluster circle + move to back 
                 		var circleSchool = d["school"]; 
                 		var corrCluster = d3.selectAll(".cluster-circle").filter(function (d) {
                 			return d["school"] == circleSchool; 
                 		}); 
                 		corrCluster.transition().duration(500).attr("r", clusterCircleSize).style("fill", DARK_PURPLE); 
                 		corrCluster.moveToBack(); 



						d3.select("#univName").text("Interactive: Hover over any circle on map or graph");
						d3.select("#univInfo").text("");
                    })

							

				/* ALL CLUSTERING SVG (ON INIT OF THE VIEW) */



				// cluster SVG container w/proper margins 
				clusterSVG = svg.append("g")
									.attr("class", "clustering")
									.attr("height", function () { return clusterHeight + 2*padding; })
									.attr("width", function () { return clusterWidth + 2*padding; })
									.attr("transform", "translate(" + xGraphOffset+ "," + yGraphOffset + ")"); 



				// Init the title of the graph 
				clusterSVG.append("text")
								.attr("class", "cluster-title")
								.attr("x", clusterWidth/2+padding)
								.attr("y", padding/2)
								.attr("alignment-baselines", "middle")
								.attr("text-anchor", "middle")
								.style("fill", DARK_PURPLE)
								.style("font-size", 16)
								.text("Acceptance Rate (%) vs. SAT Score")


				// X-Axis Label 
				clusterSVG.append("text")
					.attr("class", "x-label")
					.attr("x", clusterWidth/2 + padding)
					.attr("y", clusterHeight + padding + padding/2)
					.style("text-anchor", "middle")
					.text("SAT Score"); 


				// Y-Axis Label 
				clusterSVG.append("text")
					.attr("class", "y-label")
					.attr("transform", "rotate(-90)")
					.attr("y", 0)
					.attr("x", -clusterHeight/2 - padding)
					.attr("dy", ".71em")
					.style("text-anchor", "middle")
					.text("Acceptance Rate (%)")


				// SVG with proper dimensions 
				cSVG = clusterSVG.append("g")
										.attr("class", "graph")
										.attr("height", function () { return clusterHeight; })
										.attr("width", function () { return clusterWidth; })
										.attr("transform", "translate(" + padding + "," + padding +")"); 			
					
				// Scaling functions 
				xScale = d3.scale.linear().range([0, clusterWidth]); 
				yScale = d3.scale.linear().range([clusterHeight, 0]);

				// Axes 
				xAxis = d3.svg.axis().scale(xScale).orient("bottom"); 
				yAxis = d3.svg.axis().scale(yScale).orient("left"); 

				// Scaling of the original clustering 

				// SAT score on x-axis 
				xScale.domain(d3.extent(uniJSONs, function (d) { 
					return d["score_info"]["mean_sat_score"]; 
				})).nice(); 

				// Admissions rate on the y-axis 
				yScale.domain(d3.extent(uniJSONs, function (d) {
					return d["admissions_info"]["acceptance_rate"]; 
				})).nice(); 


				// Axes setup is based off https://bl.ocks.org/mbostock/3887118 example 

				// x-axis 
				cSVG.append("g")
					.attr("class", "x axis")
					.style("stroke", DARK_PURPLE)
					.attr("transform", "translate(0," + clusterHeight + ")")
					.call(xAxis); 

				// y-axis 
				cSVG.append("g")
					.attr("class", "y axis")
					.style("stroke", DARK_PURPLE)
					.call(yAxis); 
					


				// Modify the graph text styling 
				cSVG.selectAll(".axis text")
					.attr("class", "graph-text"); 


				// k-means cluster this info 
				var clusterResult = kMeansCluster(uniJSONs, 5, 
										"score_info", "mean_sat_score", 
										"admissions_info", "acceptance_rate") 


				// Add university dots 
				var clusterCircs = cSVG.selectAll("circle")
					.data(clusterResult[0]).enter()
				.append("circle")
					.attr("r", clusterCircleSize)
					.attr("cx", function (d) { return xScale(d["score_info"]["mean_sat_score"]); })
					.attr("cy", function (d) { return yScale(d["admissions_info"]["acceptance_rate"]); })
					.attr("class", "cluster-circle")
					.style("fill", DARK_PURPLE)
					.style("stroke", LIGHT_PURPLE)
				.on("mouseover", function (d) {
					mouseOverCallback(d, d3.select(this)); 
				})
				.on("mouseleave", function (d) {
					mouseLeaveCallback(d, d3.select(this)); 
				}); 

				// Accumulate this info for lines 
				clusterCircs.each(function (d) {
					d["cx"] = d3.select(this).attr("cx"); 
					d["cy"] = d3.select(this).attr("cy");  
				});


				// add cluster dots 
				var newClusters = cSVG.selectAll(".clusterDot")
					.data(clusterResult[1]).enter()
				.append("circle")
					.attr("r", 3)
					.attr("class", "clusterDot")
					.attr("cx", function (d) { return xScale(d["score_info"]["mean_sat_score"]); })
					.attr("cy", function (d) { return yScale(d["admissions_info"]["acceptance_rate"]); })
					.style("fill", CLUSTER_PINK)
					.style("stroke", CLUSTER_PINK)
					.on("mouseover", function (d){

						clusterMouseOver(d); 
					
					})
					.on("mouseleave",function (d) {

						clusterMouseLeave(d); 

					}); 

				// Accumulate this info for lines 
				newClusters.each(function (d) {
					d["cx"] = d3.select(this).attr("cx"); 
					d["cy"] = d3.select(this).attr("cy"); 
				}); 


				// Add appropriate lines 
				thaLines = addClusterLines(newClusters, cSVG); 
				thaLines.moveToBack(); 

				/* END OF CLUSTERING INIT */








				/* LINEAR REGRESSION GRAPHS */ 


				// Linear regression pairings 
				var pairings = 	[
									["score_info", "admissions_info", "a"], 
									["salary_info", "score_info", "b"],
									["admissions_info", "salary_info", "c"]
								]

				// To refer to linear regression axes  
				var axes_map = 	{
									"mean_sat_score" : "SAT Score",
									"acceptance_rate" : "Acceptance Rate (%)",
									"mid_career_median_salary" : "Median Mid-Career Salary (Thousands $)"
								}


				// Dimensions for each graph 
				var lgWidth = 380; 
				var lgHeight = 380; 
				var lgPadding = 60; 


				// Axes scales 
				var lgX = d3.scale.linear().range([0, lgWidth]); 
				var lgY = d3.scale.linear().range([lgHeight, 0]); 


				// Axes functions 
				var lgXAxis = d3.svg.axis()
								.scale(lgX)
								.tickFormat(function (d) {
									return d > 10000 ? d/1000.0 : d; 
								})
								.orient('bottom'); 

				var lgYAxis = d3.svg.axis()
								.scale(lgY)
								.tickFormat(function (d) {
									return d > 10000 ? d/1000.0 : d; 
								})
								.orient('left'); 


				// The offset of each graph per iteration 
				var xOffset = 450;  	


				// The current value of x for the first graph 
				var xTrack = 200; 

				// This is where we do our work 
				pairings.forEach(function (d) {

					// Set up the SVG 
					var lgSVGContainer = d3.select("#linRegSVG")
											.append("g")
											.attr("width", lgWidth+2*lgPadding)
											.attr("height", lgHeight+2*lgPadding)
											.attr("transform", "translate(" + xTrack + ", 0)")

					var lgSVG = lgSVGContainer.append("g")
										.attr("transform", "translate(" + padding + "," + padding + ")");	

						
					// Each type of data is namespaced in the uniJSONs array, so obtain these from the array above 
					var xNameSpace = d[0]; 
					var yNameSpace = d[1]; 

					// Label for the dot classes 
					var dotClass = "lin-reg-dot-" + d[2]; 

					// Obtain the names of the actual data values under these namespaces 
					var xInfo = DATA_MAPPINGS[xNameSpace]; 
					var yInfo = DATA_MAPPINGS[yNameSpace]; 

					// xExtent
					var xExtent = d3.extent(uniJSONs, function (d) {
						return d[xNameSpace][xInfo]; 
					}); 

					// yExtent 
					var yExtent = d3.extent(uniJSONs, function (d) {
						return d[yNameSpace][yInfo]; 
					}); 

					// Set the domains for the scales according to the data values 
					lgX.domain(xExtent).nice(); 
					lgY.domain(yExtent).nice(); 

					// Add the x and y axis to the view 
					// x-axis function 
					lgSVG.append("g")
						.attr("class", "x axis")
						.attr("transform", "translate(0," + lgHeight + ")")
						.style("stroke", DARK_PURPLE)
						.call(lgXAxis); 

					// y-axis function 
					lgSVG.append("g")
						.attr("class", "y axis")
						.style("stroke", DARK_PURPLE)
						.call(lgYAxis); 

					// Modify the graph text styling 
					lgSVG.selectAll(".axis text")
						.attr("class", "graph-text"); 
						xTrack += xOffset


					// Init the title of the graph 
					lgSVGContainer.append("text")
							.attr("class", "reg-title")
							.attr("x", lgWidth/2+lgPadding)
							.attr("y", lgPadding/2)
							.attr("alignment-baselines", "middle")
							.attr("text-anchor", "middle")
							.style("fill", DARK_PURPLE)
							.style("font-size", 12)
							.text(function() {
								var yTitle = axes_map[yInfo]; 
								var xTitle = axes_map[xInfo]; 
								return yTitle + " vs. " + xTitle; 
							})


					// X-Axis Label 
					lgSVGContainer.append("text")
						.attr("class", "x-label")
						.attr("x", lgWidth/2 + lgPadding)
						.attr("y", lgHeight + lgPadding + lgPadding/2)
						.style("text-anchor", "middle")
						.text(axes_map[xInfo]); 


					// Y-Axis Label 
					lgSVGContainer.append("text")
						.attr("class", "y-label")
						.attr("transform", "rotate(-90)")
						.attr("y", 20)
						.attr("x", -lgHeight/2 - lgPadding)
						.attr("dy", ".71em")
						.style("text-anchor", "middle")
						.text(axes_map[yInfo]); 


					// Add dots 
					lgSVG.selectAll(".lingRegDot")
						.data(uniJSONs).enter()
					.append("circle")
						.style("stroke", LIGHT_PURPLE)
						.style("fill", DARK_PURPLE)
						.attr("class", dotClass)
						.attr("r", 3.5)
						.attr("cx", function (d) {
							return lgX(d[xNameSpace][xInfo])
						})
						.attr("cy", function (d) {
							return lgY(d[yNameSpace][yInfo])
						})


					// Perform linear regression + obtain B1 and B0 coefficients 
					var linRegResult = linearRegression(uniJSONs, xNameSpace, xInfo, yNameSpace, 
														yInfo); 
					var B1 = linRegResult[0]; 
					var B0 = linRegResult[1];  

					console.log(B1); 
					console.log(B0); 

					// Get boundary x-values (raw, unscaled)
					var x1 = xExtent[0]; 
					var x2 = xExtent[1]; 

					// Perform line computation to get y's (raw, unscaled)
					var y1 = B1 * x1 + B0; 
					var y2 = B1 * x2 + B0; 

					// Add the line to the graph + ensure it's in the front 
					// Ensure scaling of x1, y1, x2, y2 
					var linRegLine = lgSVG.append("line")	
											.attr("x1", lgX(x1)).attr("y1", lgY(y1))
											.attr("x2", lgX(x2)).attr("y2", lgY(y2))
											.attr("class", "lin-reg-line")
											.style("opacity", 1)
											.style("stroke", PINK)
											.style("stroke-width", 3);
					linRegLine.moveToFront(); 	

					var linRegDots = d3.selectAll("." + dotClass)
					.on("mouseover", function () {
						var myDot = d3.select(this); 	
						console.log(myDot.attr("cx")); 
					}); 





				}); 
	


				



				/* END OF LINEAR REGRESSION GRAPHS */





			});
			

			// Basic color fade-in on load up for map 
			$(document).ready(function() {
				// Set to 0 initially 
				$('svg').css("fill-opacity", "0"); 
				// Animate it in 
				$('svg').animate({
					"fill-opacity": "1.0"
				}, 1000, function() {}); 

			}); 


			// Clustering parameter selection 
			$(".cluster-btn").on("click", function (e) {
				// Push this on if it's not in the array already 
				var inArray = false; 
				var s = $(this); 
				selectedParms.forEach(function (d) {
					inArray = inArray || (d.attr("data") == s.attr("data"))
				}); 
				if (!inArray) {
					selectedParms.push($(this)); 
					$(this).css("background", PINK); 
					if (selectedParms.length > 2) {
						var removedButton = selectedParms.splice(0, 1)[0]; // Remove the first element
						removedButton.css("background", LIGHT_PURPLE); 
					}		
				}
			}); 


			// Reset the view 
			$(".reset-btn").on("click", function (e) {
				// Empty these 
				selectedParms = []; 
				selectedStates = [];

				// Reset all map circles 
				d3.selectAll(".map-circle").style("fill", DARK_PURPLE).style("stroke", "white"); 

				// Reset all states 
				d3.selectAll(".state").style("fill", LIGHT_PURPLE); 

				// Remove the clusters + dots + lines 
				d3.selectAll(".clusterDot").remove(); 
				d3.selectAll(".cluster-circle").remove(); 
				d3.selectAll(".cluster-line").remove(); 

				// Reset the button colors 
				$(".cluster-btn").css("background", LIGHT_PURPLE); 


			}); 



			/* CLUSTERING INTERACTION */


			// Clustering bulk work 
			$(".start-cluster").on("click", function (e) {

				// Can't run clustering on <2 params
				if (selectedParms.length < 2) {
					alert("Please select 2 parameters to cluster by");
					return; 
				}	


				// Accumulate the actual data 
				var relevantData = []; 

				// Curate the dots 
				var selectedDots = d3.selectAll(".map-circle")
										.filter(function (d) {
											var dotState = d["location_info"]["state"]; 
											var inArray = false; 
											selectedStates.forEach(function (s) {
												inArray = inArray || (s == dotState); 
											}); 

											// Populate the above array at the same time 
											if (inArray) {
												var dataCopy = JSON.parse(JSON.stringify(d)); 
												relevantData.push(dataCopy); 
											} 

											return inArray; 
										}); 


				// Can't run clustering on no data
				if (selectedDots[0].length < 1) {
					alert("Please select states with universities in them"); 
					return; 
				}	


				// Accumulate the dot locations 
				var currentDotLocations = [];
				selectedDots.each(function (d, i) {
					var cx = parseFloat(d3.select(this).attr("cx")); 
					var cy = parseFloat(d3.select(this).attr("cy")); 
					var dic = { cx: cx, cy: cy }; 
					currentDotLocations.push(dic); 
				}); 


				// Remove these 
				d3.selectAll(".cluster-circle").remove(); 
				d3.selectAll(".clusterDot").remove(); 
				d3.selectAll(".cluster-line").remove(); 
				

				// Intersect the two data sets 
				overAllData = []; 
				for (var i = 0; i < relevantData.length; i++) {
					// Combine the two 
					for (var attr in currentDotLocations[i]) {
						relevantData[i][attr] = currentDotLocations[i][attr]; 
					}
					// Add them to overAllData
					overAllData.push(relevantData[i]); 
				}	


				// Obtain the data fields 
				var firstParam = selectedParms[0].attr("data"); 
				var firstData = DATA_MAPPINGS[selectedParms[0].attr("data")]; 
				var secondParam = selectedParms[1].attr("data"); 
				var secondData = DATA_MAPPINGS[selectedParms[1].attr("data")]; 


				// k-means cluster this info 
				var clusterResult = kMeansCluster(overAllData, 5, 
										firstParam, firstData, 
										secondParam, secondData)

				overAllData = clusterResult[0]; 

				// UPDATING CLUSTERING SCALING + SUCH 


				// Rescale x + y axes based on the new overall data 
				xScale.domain(d3.extent(overAllData, function (d) { 
					return d[firstParam][firstData]; 
				})).nice(); 

				yScale.domain(d3.extent(overAllData, function (d) {
					return d[secondParam][secondData]; 
				})).nice(); 


				// Remove current axes 
				d3.select(".x.axis").remove();
				d3.select(".y.axis").remove(); 


				// Reset Title + Axes Labels 
				// Get two titles 
				var titleOne = TITLE_MAPPINGS[secondData];
				var titleTwo = TITLE_MAPPINGS[firstData]; 
				var title = d3.select(".cluster-title").text(titleOne + " vs. " + titleTwo); 
				var xLabel = d3.select(".x-label").text(titleTwo); 
				var yLabel = d3.select(".y-label").text(titleOne); 


				// Reestablish axes 

				// Axes 
				xAxis = d3.svg.axis().scale(xScale).orient("bottom"); 
				yAxis = d3.svg.axis().scale(yScale).orient("left"); 

				// x-axis 
				cSVG.append("g")
					.attr("class", "x axis")
					.style("stroke", DARK_PURPLE)
					.attr("transform", "translate(0," + clusterHeight + ")")
					.call(xAxis); 

				// y-axis 
				cSVG.append("g")
					.attr("class", "y axis")
					.style("stroke", DARK_PURPLE)
					.call(yAxis); 

				// Modify the graph text styling 
				cSVG.selectAll(".axis text")
					.attr("class", "graph-text"); 



				// Add those cluster circles to the current cx and cy 
				var newClusterCircles = svg.selectAll(".cluster-circle")
							.data(overAllData).enter()
						.append("circle")
							.attr("r", clusterCircleSize)
							.attr("cx", function (d) { return d["cx"] })
							.attr("cy", function (d) { return d["cy" ]})
							.attr("class", "cluster-circle")
							.style("fill", DARK_PURPLE)
							.style("stroke", LIGHT_PURPLE)
						.on("mouseover", function (d) {
							mouseOverCallback(d, d3.select(this)); 
						})
						.on("mouseleave", function (d) {
							mouseLeaveCallback(d, d3.select(this)); 
						}); 


				// Move them to proper space on the clustering graph
				newClusterCircles.each(function (d) {
					var cx = xScale(d[firstParam][firstData]); 
					var cy = yScale(d[secondParam][secondData]); 
					var trueCX = cx + xGraphOffset + padding; 
					var trueCY = cy + yGraphOffset + padding; 
					d["cx"] = trueCX; 
					d["cy"] = trueCY; 
					d3.select(this).transition()
						.attr("cx", trueCX)
						.attr("cy", trueCY); 
				}); 


				// add cluster dots 		
				var newClusters = svg.selectAll(".clusterDot")
					.data(clusterResult[1]).enter()
				.append("circle")
					.attr("r", 3)
					.attr("class", "clusterDot")
					.attr("cx", function (d) { 
						var cx = xScale(d[firstParam][firstData]); 
						var trueCX = cx + xGraphOffset + padding; 
						d["cx"] = trueCX; 
						return trueCX; 
					})
					.attr("cy", function (d) { 
						var cy = yScale(d[secondParam][secondData]); 
						var trueCY = cy + yGraphOffset + padding; 
						d["cy"] = trueCY; 
						return trueCY; 
					})
					.style("fill", CLUSTER_PINK)
					.style("stroke", CLUSTER_PINK)
					.style("opacity", 0).on("mouseover", function (d) {

						clusterMouseOver(d); 
					
					})
					.on("mouseleave", function (d) {

						clusterMouseLeave(d); 

					});  

				newClusters.transition().duration(1000).style("opacity", 1.0); 



				// Accumulate dot - cluster associations 
				thaLines = addClusterLines(newClusters, svg); 
				thaLines.moveToBack(); 

			}); 

		
		</script> 

	</body> 


</html> 













